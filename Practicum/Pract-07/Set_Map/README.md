
# `std::set` и `std::map`

## Въведение в `std::set`

`std::set` е асоциативен контейнер, който съхранява уникални обекти в сортиран ред. Обикновено е реализиран чрез червено-черни дървета.

При създаване на обект от тип `std::set`, могат да се зададат три типа параметри:


```c++
template<
    class Key,
    class Compare = std::less<Key>,
    class Allocator = std::allocator<Key>
> class set;
```
- **Key**  
  Типът на обектите, които ще се съхраняват в множеството.

- **Compare**  
  Функция или обект за сравнение, която определя критерия за сравнение между елементите. Това влияе върху начина, по който множеството подрежда елементите.  
  *По подразбиране:* Използва се стандартният оператор за сравнение за съответния тип (`std::less<Key>`).

- **Allocator**  
  Механизъм за управление на паметта, който определя как ще се разпределя и освобождава паметта за елементите в множеството.  
  *По подразбиране:* Използва се стандартният алокатор `std::allocator<Key>`.


## Операции

- **Добавяне на елементи**: `set.insert(value)` - O(logN)
- **Премахване на елементи**: `set.erase(value)`- O(logN) (връща колко елементи са били премахнати)
- **Премахване на елементи чрез итератор**: `set.erase(iterator)`- Θ(1) / O(logN) (връща итератор към следващия елемент)
- **Търсене на елементи**: `set.find(value);` - O(logN) (връща итератор или `set.end()`, ако не е намерен)
- **Проверка на размера**: `set.size()` - O(1)

---

```c++
#include <iostream>
#include <map>

int main() {

    std::set<int> mySet = { 3, 1, 2, 5, 4 , 8, 3};

    for (auto it = mySet.begin(); it != mySet.end();) 
    {
        if (*it % 2 == 0)
        {
            it = mySet.erase(it);
        }
        else
        {
            it++;
        }
    }

    // Гарантирано изпечтване в сортиран вид
    for (auto& el : mySet)
    {
        std::cout << el << ' ';
    }

    return 0;
}
```


## Въведение в `std::map`

`std::map` е асоциативен контейнер, който съхранява двойки ключ-стойност в сортиран ред по ключовете. Ключовете са уникални, и всеки ключ съответства на една стойност.Обикновено е реализиран чрез червено-черни дървета.

- **Key**  
  Типът на обектите, които ще се съхраняват в множеството.

- **T**  
  Типът на обектите, които ще се съхраняват в множеството.

- **Compare**  
  Обект или функция за сравнение, която определя как ключовете се подреждат в контейнера.
  *По подразбиране:* Използва се стандартният оператор за сравнение за съответния тип на ключа (`std::less<Key>`).

- **Allocator**  
  Механизъм за управление на паметта, който определя как ще се разпределя и освобождава паметта за елементите в множеството.  
  *По подразбиране:* Използва се стандартният алокатор `std::allocator<std::pair<const Key, T>>`.


```c++
template<
    class Key,
    class T,
    class Compare = std::less<Key>,
    class Allocator = std::allocator<std::pair<const Key, T>>

> class map;
```

---

### Операции
- **Добавяне на елементи**: `map[key] = value`- O(logN)
- **Достъп до елементи**: `map[key]` - O(logN)
- **Премахване на елементи**: `map.erase(key)` - O(logN) (връща колко елементи са били премахнати)
- **Премахване на елементи чрез итератор**: `map.erase(iterator)` - Θ(1) / O(logN) (връща итератор към следващия елемент)
- **Търсене на елементи**: `map.find(key)` - O(logN) (връща итератор или `map.end()`, ако не е намерен)
- **Проверка на размера**: `map.size()` - O(1)
---


```c++
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> myMap = {
        {3, "Three"},
        {1, "One"},
        {2, "Two"}
    };

    for (auto it = myMap.begin(); it != myMap.end(); ++it) 
    {
        std::cout << "Key: " << it->first << ", Value: " << it->second << '\n';
    }

    for (auto& pair : myMap)
    {
        std::cout << "Key: " << pair.first << ", Value: " << pair.second << '\n';
    }

    // C++ 17
    for (auto& [key, value] : myMap)
    {
        std::cout << "Key: " << key << ", Value: " << value << '\n';
    }

    return 0;
}
```

## Въпрос
 Как можем да определим дали даден елемент/ключ вече съществува в дървото, когато единственото средство за сравнение между елементите/ключовете е предоставеният компаратор (Comparator)?
