# Сливане на два сортирани диапазона
Сливането е процес на комбиниране на два сортирани диапазона в един, като новият диапазон остава сортиран.

## Подходи за сливане

### 1. **Първи вариант**

Този подход минимизира броя на проверките, като директно копира оставащите елементи от един от диапазоните, когато другият свърши. Това е полезно в ситуации, когато единият от диапазоните е значително по-къс или по-дълъг от другия.

#### Основни стъпки:
1. **Основен цикъл**: Проверяваме елементите от двата диапазона и слагаме по-малкия в предварително заделен буфер. Буферът представлява предварително заделена памет, където ще се записват резултатите от сливането.
2. **Ранно приключване**: Ако единият диапазон свърши, директно копираме оставащите елементи от другия диапазон в буфера без повече сравнения.
3. **Крайни елементи**: Ако има оставащи елементи в някой от диапазоните, те се копират в буфера.

```c++
template<class RandomIt>
void merge(RandomIt first1, RandomIt last1,
    RandomIt first2, RandomIt last2,
    RandomIt buff)
{
    // Основен цикъл: въртим, докато не сме достигнали края на първия подмасив
    for (; first1 != last1; ++buff)
    {
        // Ако вторият подмасив е изчерпан, директно копираме остатъка от първия подмасив
        if (first2 == last2)
        {
            // Копираме остатъка от първия подмасив в буфера
            for (; first1 != last1; ++first1, ++buff)
                *buff = *first1;

            return; // Излизаме от функцията, защото всичко вече е копирано
        }

        // Сравняваме текущите елементи от двата подмасива
        if (*first2 < *first1)
        {
            // Копираме елемента от втория подмасив, ако е по-малък от елемента от първия
            *buff = *first2;
            ++first2; // Придвижваме се към следващия елемент на втория подмасив
        }
        else
        {
            // Копираме елемента от първия подмасив, ако е по-малък или равен от елемента от втория
            *buff = *first1;
            ++first1; // Придвижваме се към следващия елемент на първия подмасив
        }
    }

    // Ако все още имаме останали елементи във втория подмасив, копираме ги в буфера
    for (; first2 != last2; ++first2, ++buff)
        *buff = *first2;
}
```

### 2. **Втори вариант**

Този подход сравнява елементите от двата диапазона един по един и ги копира в буфера. Това е полезно в ситуации, когато двата диапазона са сравнително равни по дължина. Процесът на сливане протича последователно до момента, когато един от диапазоните се изчерпи.

#### Основни стъпки:
1. **Основен цикъл**: Сравняваме текущите елементи от двата диапазона и копираме по-малкия елемент в буфера.
2. **Крайни елементи**: Ако някой от диапазоните свърши, остават елементи само в другия, които директно се копират в буфера.

```c++
template <class RandomIt>
void merge(RandomIt first1, RandomIt last1,
    RandomIt first2, RandomIt last2,
    RandomIt buff)
{
    // Докато и двата диапазона имат оставащи елементи
    while (first1 != last1 && first2 != last2)
    {
        // Сравняваме текущите елементи от двата подмасива
        if (*first1 <= *first2)
        {
            // Ако елементът от първия подмасив е по-малък или равен, го копираме в буфера
            *buff = *first1;
            ++first1; // Придвижваме се към следващия елемент на първия подмасив
        }
        else
        {
            // Ако елементът от втория подмасив е по-малък, го копираме в буфера
            *buff = *first2;
            ++first2; // Придвижваме се към следващия елемент на втория подмасив
        }
        ++buff; // Придвижваме се към следващата позиция в буфера
    }

    // Копиране на оставащите елементи от първия подмасив, ако има такива
    while (first1 != last1)
    {
        *buff = *first1;
        ++first1;
        ++buff;
    }

    // Копиране на оставащите елементи от втория подмасив, ако има такива
    while (first2 != last2)
    {
        *buff = *first2;
        ++first2;
        ++buff;
    }
}

```

## Сравнение на двата подхода

| *Характеристика*                  | *Първи подход*                                                          | *Втори подход*                                         |
|-----------------------------------|-------------------------------------------------------------------------|--------------------------------------------------------|
| **Брой проверки**                 | По-малко проверки, особено при различни дължини на диапазоните.         | Редовни проверки при всяка итерация.                   |
| **Ефективност**                   | По-ефективен, когато единият диапазон е значително по-кратък от другия. | Подходящ за диапазони с приблизително еднаква дължина. |
| **Четливост на кода**             | Леко по-сложен за разбиране, но оптимизиран.                            | По-прост и лесен за разбиране.                         |
| **Копиране на оставащи елементи** | Бързо директно копиране, когато един диапазон е изчерпан.               | Копира оставащите елементи след сравняване.            |
| **Подходящ за**                   | Диапазони с различни размери.                                           | Диапазони с подобни размери.                           |

## Сложност 

- *Времева сложност*: **O(n + m)**, защото се преминава през всеки елемент на двата диапазона.
- *Пространствена сложност*: **O(n + m)**, защото се използва допълнителен буфер за съхранение на резултата от сливането с размер **n + m**.

> Където **n** и **m** са дължините на двата диапазона.